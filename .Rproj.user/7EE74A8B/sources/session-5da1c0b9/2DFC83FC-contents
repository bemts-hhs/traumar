#' Create Nonlinear Probability of Survival Bins
#'
#' This function generates nonlinear bins for probability of survival data based
#' on specified thresholds and divisors. It calculates bin statistics, including
#' mean, standard deviation, count, and percentage for each bin.
#'
#' @param data A `data.frame` or `tibble` containing the probability of survival
#'   data for a set of patients.
#' @param Ps_col The column in `data` containing the probability of survival
#'   values for a set of patients.
#' @param divisor1 A parameter to control the width of the probability of
#'   survival range bins. Affects the creation of step sizes for the beginning
#'   of each bin range. Defaults to `5`.
#' @param divisor2 A parameter to control the width of the probability of
#'   survival range bins. Affects the creation of step sizes for the beginning
#'   of each bin range. Defaults to `5`.
#' @param threshold_1 A parameter to decide where data indices will begin to
#'   create step sizes. Defaults to `0.9`.
#' @param threshold_2 A parameter to decide where data indices will end to
#'   create step sizes. Defaults to `0.99`.
#'
#' @returns A list with `intervals` and `bin_stats` objects:
#' * `intervals`: A vector of start and end-points for the probability of survival bin ranges.
#' * `bin_stats`: A `tibble` with columns `bin_number`, `bin_start`, `bin_end`, `mean`, `sd`, `count`, and `percent`.
#'
#' @export
#'
#' @examples
#' # Generate example data with high negative skewness
#' set.seed(123)
#' survival_probs <- rbeta(10000, shape1 = 5, shape2 = 1)
#' example_data <- data.frame(patient_id = 1:10000, survival_probability = survival_probs)
#'
#' # Apply the nonlinear_bins function
#' results <- nonlinear_bins(data = example_data,
#'                           Ps_col = survival_probability,
#'                           divisor1 = 5,
#'                           divisor2 = 5,
#'                           threshold_1 = 0.9,
#'                           threshold_2 = 0.99)
#'
#' # View results
#' results$intervals
#' results$bin_stats
#'
#' @author Nicolas Foss, Ed.D, MS, original paper and code in MATLAB by Nicholas
#'   J. Napoli, Ph.D., MS
#'
nonlinear_bins <- function(data,
                           Ps_col,
                           divisor1 = 5,
                           divisor2 = 5,
                           threshold_1 = 0.9,
                           threshold_2 = 0.99
                           ) {

  # Select and sort the column
  survival_data <- data |> dplyr::pull({{ Ps_col }}) |> sort()
  total <- length(survival_data)

  # Step 1: Find indices for level thresholds
  loc_9A <- which(survival_data > threshold_1) # Everything above 0.9 or other threshold
  loc_9B <- which(survival_data > threshold_2) # Everything above 0.99 or other threshold
  loc_9C <- which(survival_data > threshold_1 & survival_data <= threshold_2) # Between 0.9 and 0.99 or other thresholds

  # Step 2: Define step sizes based on the data
  step1 <- round(min(loc_9A) / divisor1)
  step2 <- round(length(loc_9C) / divisor2)

  # Step 3: Define intervals
  len <- unique(c(
    seq(1, min(loc_9A), by = step1),        # From start to level_1
    seq(min(loc_9A), min(loc_9B), by = step2), # From level_1 to level_2
    max(loc_9B)                             # Up to max
  ))

  # Generate intervals based on these positions
  intervals <- unique(survival_data[len])

  # Step 4: Bin statistics
  # Create empty tibble for bin stats
  bin_stats <- tibble::tibble(
    bin_number = seq_along(head(intervals, -1)),
    bin_start = utils::head(intervals, -1),
    bin_end = utils::tail(intervals, -1),
    mean = numeric(length(intervals) - 1),
    sd = numeric(length(intervals) - 1),
    count = numeric(length(intervals) - 1),
    percent = numeric(length(intervals) - 1)
  )


  # Populate bin stats
  for (i in seq_len(nrow(bin_stats))) {
    bin_data <- survival_data[survival_data >= bin_stats$bin_start[i] &
                                (survival_data < bin_stats$bin_end[i] | i == nrow(bin_stats))]
    if (length(bin_data) > 0) {
      bin_stats$bin_number[i] <- i
      bin_stats$mean[i] <- mean(bin_data)
      bin_stats$sd[i] <- stats::sd(bin_data)
      bin_stats$count[i] <- length(bin_data)
      bin_stats$percent[i] <- round(length(bin_data) / total, digits = 3)
    } else {
      bin_stats$mean[i] <- NA
      bin_stats$sd[i] <- NA
      bin_stats$count[i] <- 0
    }
  }

  return(list(intervals = intervals, bin_stats = bin_stats))

}

